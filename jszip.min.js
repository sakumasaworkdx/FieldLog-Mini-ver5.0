/* Minimal JSZip-compatible ZIP builder (STORE only)
   - provides window.JSZip
   - supports: new JSZip(); zip.file(name, Blob|ArrayBuffer|Uint8Array|string); zip.folder(name); zip.generateAsync({type:"blob"})
   - no compression (store), suitable for offline small/medium sets
*/
(function(){
  function u16(v){ return [v&255,(v>>>8)&255]; }
  function u32(v){ return [v&255,(v>>>8)&255,(v>>>16)&255,(v>>>24)&255]; }

  // ---- CRC32 ----
  var CRC_TABLE = (function(){
    var t = new Uint32Array(256);
    for (var i=0;i<256;i++){
      var c=i;
      for (var k=0;k<8;k++){
        c = (c & 1) ? (0xEDB88320 ^ (c>>>1)) : (c>>>1);
      }
      t[i]=c>>>0;
    }
    return t;
  })();

  function crc32(bytes){
    var c = 0xFFFFFFFF;
    for (var i=0;i<bytes.length;i++){
      c = CRC_TABLE[(c ^ bytes[i]) & 0xFF] ^ (c >>> 8);
    }
    return (c ^ 0xFFFFFFFF) >>> 0;
  }

  function encUTF8(str){
    if (typeof TextEncoder !== "undefined") return new TextEncoder().encode(str);
    // fallback (very old): naive
    var utf8=[];
    for (var i=0;i<str.length;i++){
      var code=str.charCodeAt(i);
      if (code<0x80) utf8.push(code);
      else if (code<0x800){ utf8.push(0xC0|(code>>6),0x80|(code&0x3F)); }
      else { utf8.push(0xE0|(code>>12),0x80|((code>>6)&0x3F),0x80|(code&0x3F)); }
    }
    return new Uint8Array(utf8);
  }

  function asUint8(data){
    if (data instanceof Uint8Array) return data;
    if (data instanceof ArrayBuffer) return new Uint8Array(data);
    if (typeof data === "string") return encUTF8(data);
    return null;
  }

  function toArrayBuffer(blob){
    if (blob instanceof Blob) return blob.arrayBuffer();
    var u = asUint8(blob);
    if (u) return Promise.resolve(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
    return Promise.reject(new Error("Unsupported data type"));
  }

  // ---- DOS time/date from Date ----
  function dosTime(d){
    var h=d.getHours(), m=d.getMinutes(), s=Math.floor(d.getSeconds()/2);
    return (h<<11) | (m<<5) | s;
  }
  function dosDate(d){
    var y=d.getFullYear();
    var mo=d.getMonth()+1;
    var da=d.getDate();
    return ((y-1980)<<9) | (mo<<5) | da;
  }

  function JSZip(prefix){
    this._p = prefix || "";
    this._files = []; // {nameBytes, nameStr, dataU8, crc, size, offset, mtime, mdate}
  }

  JSZip.prototype.folder = function(name){
    var p = this._p + (name || "");
    if (p && p[p.length-1] !== "/") p += "/";
    return new JSZip(p);
  };

  JSZip.prototype.file = function(name, data){
    var self=this;
    var full = this._p + name;
    // Normalize to forward slashes
    full = full.replace(/\\/g,"/");
    return toArrayBuffer(data).then(function(ab){
      var u8 = new Uint8Array(ab);
      var crc = crc32(u8);
      var nb = encUTF8(full);
      var d = new Date();
      self._files.push({
        nameStr: full,
        nameBytes: nb,
        dataU8: u8,
        crc: crc,
        size: u8.length,
        offset: 0,
        mtime: dosTime(d),
        mdate: dosDate(d)
      });
      return self;
    });
  };

  JSZip.prototype.generateAsync = function(opts){
    opts = opts || {};
    var self=this;

    // If user used folder().file(), those files are in different instance.
    // Typical usage here is root zip only. So we only package files attached to this instance.
    // (Our app uses zip.folder("photos") but calls folder.file via returned object.
    // That object is new instance, so we need to share storage.
    // Fix: make folder share same _files array. We'll implement by copying reference.
    return (function(){
      // Ensure any nested folder instance shares same _files:
      // (handled below by monkey patch in constructor)
      return Promise.resolve();
    })().then(function(){
      // Wait for any pending promises? Our API returns Promise from file(), caller awaits.
      // So here assume files are ready.
      var files = self._files;
      // Build local headers + data
      var parts = [];
      var central = [];
      var offset = 0;

      for (var i=0;i<files.length;i++){
        var f = files[i];
        f.offset = offset;

        // Local file header
        // signature 0x04034b50
        var lh = [];
        lh.push.apply(lh, u32(0x04034b50));
        lh.push.apply(lh, u16(20));           // version needed
        lh.push.apply(lh, u16(0));            // flags
        lh.push.apply(lh, u16(0));            // compression = 0 (store)
        lh.push.apply(lh, u16(f.mtime));      // mod time
        lh.push.apply(lh, u16(f.mdate));      // mod date
        lh.push.apply(lh, u32(f.crc));        // crc32
        lh.push.apply(lh, u32(f.size));       // compressed size
        lh.push.apply(lh, u32(f.size));       // uncompressed size
        lh.push.apply(lh, u16(f.nameBytes.length)); // filename length
        lh.push.apply(lh, u16(0));            // extra length

        var lhU8 = new Uint8Array(lh);
        parts.push(lhU8, f.nameBytes, f.dataU8);
        offset += lhU8.length + f.nameBytes.length + f.dataU8.length;

        // Central directory header
        var ch = [];
        ch.push.apply(ch, u32(0x02014b50));   // signature
        ch.push.apply(ch, u16(20));           // version made by
        ch.push.apply(ch, u16(20));           // version needed
        ch.push.apply(ch, u16(0));            // flags
        ch.push.apply(ch, u16(0));            // compression
        ch.push.apply(ch, u16(f.mtime));
        ch.push.apply(ch, u16(f.mdate));
        ch.push.apply(ch, u32(f.crc));
        ch.push.apply(ch, u32(f.size));
        ch.push.apply(ch, u32(f.size));
        ch.push.apply(ch, u16(f.nameBytes.length)); // filename length
        ch.push.apply(ch, u16(0));            // extra
        ch.push.apply(ch, u16(0));            // comment length
        ch.push.apply(ch, u16(0));            // disk number
        ch.push.apply(ch, u16(0));            // internal attrs
        ch.push.apply(ch, u32(0));            // external attrs
        ch.push.apply(ch, u32(f.offset));     // local header offset
        var chU8 = new Uint8Array(ch);
        central.push(chU8, f.nameBytes);
      }

      var centralSize = 0;
      for (var j=0;j<central.length;j++) centralSize += central[j].length;

      // End of central directory
      var eocd = [];
      eocd.push.apply(eocd, u32(0x06054b50)); // signature
      eocd.push.apply(eocd, u16(0));          // disk number
      eocd.push.apply(eocd, u16(0));          // start disk
      eocd.push.apply(eocd, u16(files.length));
      eocd.push.apply(eocd, u16(files.length));
      eocd.push.apply(eocd, u32(centralSize));
      eocd.push.apply(eocd, u32(offset));     // central dir offset
      eocd.push.apply(eocd, u16(0));          // comment length
      var eocdU8 = new Uint8Array(eocd);

      var outParts = parts.concat(central);
      outParts.push(eocdU8);

      if (opts.type === "blob" || !opts.type){
        return new Blob(outParts, {type:"application/zip"});
      }
      // only blob supported for our use
      return new Blob(outParts, {type:"application/zip"});
    });
  };

  // Make folder share same file list (important!)
  var _origFolder = JSZip.prototype.folder;
  JSZip.prototype.folder = function(name){
    var z = _origFolder.call(this, name);
    z._files = this._files; // share
    return z;
  };

  // Expose
  window.JSZip = JSZip;
})();
